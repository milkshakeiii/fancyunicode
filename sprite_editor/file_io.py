"""
Sprite & Scene Editor - File I/O functions
"""

import os
import sys
import pygame
import pyunicodegame

try:
    from . import models
    from .models import (
        state,
        DEFAULT_CANVAS_WIDTH, DEFAULT_CANVAS_HEIGHT, DEFAULT_FG,
        Cell, SpriteFrame, AnimationFrame, AnimationDef, SpriteInstance,
    )
except ImportError:
    import models
    from models import (
        state,
        DEFAULT_CANVAS_WIDTH, DEFAULT_CANVAS_HEIGHT, DEFAULT_FG,
        Cell, SpriteFrame, AnimationFrame, AnimationDef, SpriteInstance,
    )


GENERATED_DIR = "generated_files"


def save_file(path: str):
    """Save as executable Python code (sprite or scene format)"""
    if not path.endswith('.py'):
        path += '.py'

    # Put files in generated_files/ unless path is absolute or already has a directory
    if not os.path.isabs(path) and os.path.dirname(path) == '':
        os.makedirs(GENERATED_DIR, exist_ok=True)
        path = os.path.join(GENERATED_DIR, path)

    try:
        # Save current cells to current frame before saving
        if state.editor_mode == "sprite":
            state.frames[state.current_frame].cells = dict(state.cells)
            code = generate_sprite_code(os.path.basename(path))
        else:
            code = generate_scene_code(os.path.basename(path))

        with open(path, 'w', encoding='utf-8') as f:
            f.write(code)

        state.file_path = path
        state.modified = False
        state.set_status(f"Saved: {path}")
    except Exception as e:
        state.set_status(f"Error saving: {e}")


def generate_sprite_code(filename: str) -> str:
    """Generate sprite library Python code with SPRITE_DEFS"""
    lines = [
        '#!/usr/bin/env python3',
        '"""',
        f'Sprite Library - Generated by scene_editor',
        '"""',
        '',
        'import pyunicodegame',
        '',
        '',
        '# Sprite definitions for editor reload and runtime use',
        'SPRITE_DEFS = {',
    ]

    # Build sprite definition
    sprite_name = state.sprite_name
    lines.append(f"    {repr(sprite_name)}: {{")
    lines.append(f"        'width': {state.canvas_width},")
    lines.append(f"        'height': {state.canvas_height},")
    lines.append(f"        'default_fg': {state.current_fg},")
    lines.append("        'frames': [")

    # Add each frame
    for frame_idx, frame in enumerate(state.frames):
        frame_dict = frame.to_dict(state.canvas_width, state.canvas_height)

        lines.append("            {")
        # Format chars as 2D array
        lines.append("                'chars': [")
        for row in frame_dict['chars']:
            row_repr = '[' + ', '.join(repr(c) for c in row) + ']'
            lines.append(f"                    {row_repr},")
        lines.append("                ],")

        # Format fg_colors (only include non-None values for readability)
        lines.append("                'fg_colors': [")
        for row in frame_dict['fg_colors']:
            row_repr = '[' + ', '.join(str(c) if c else 'None' for c in row) + ']'
            lines.append(f"                    {row_repr},")
        lines.append("                ],")
        lines.append("            },")

    lines.append("        ],")

    # Add animations if any
    if state.animations:
        lines.append("        'animations': {")
        for anim_name, anim in sorted(state.animations.items()):
            # 3-tuple: (frame_index, offset_x, offset_y)
            frames_repr = ', '.join(
                f"({af.frame_index}, {af.offset_x}, {af.offset_y})"
                for af in anim.frames
            )
            lines.append(f"            {repr(anim_name)}: {{")
            lines.append(f"                'frames': [{frames_repr}],")
            lines.append(f"                'frame_duration': {anim.frame_duration},")
            lines.append(f"                'loop': {anim.loop},")
            lines.append("            },")
        lines.append("        },")

    lines.append("    },")
    lines.append("}")
    lines.append("")
    lines.append("")

    # Add helper function
    lines.extend([
        "def create_sprite(name: str, x: int, y: int):",
        '    """Create a pyunicodegame sprite from definition."""',
        "    defn = SPRITE_DEFS[name]",
        "    frame = defn['frames'][0]",
        "    pattern = '\\n'.join(''.join(row) for row in frame['chars'])",
        "    sprite = pyunicodegame.create_sprite(pattern, x, y, fg=defn['default_fg'])",
        "    # Add additional frames if present",
        "    for f in defn['frames'][1:]:",
        "        pattern = '\\n'.join(''.join(row) for row in f['chars'])",
        "        sprite.add_frame(pattern)",
        "    return sprite",
        "",
        "",
    ])

    # Add demo main function
    lines.extend([
        "def main():",
        f'    """Demo: display the sprite"""',
        f"    root = pyunicodegame.init(",
        f'        "Sprite: {state.sprite_name}",',
        f"        width={max(20, state.canvas_width + 4)},",
        f"        height={max(10, state.canvas_height + 4)},",
        f"        bg=(10, 10, 20, 255)",
        f"    )",
        "",
        f"    sprite = create_sprite({repr(state.sprite_name)}, 2, 2)",
        "    root.add_sprite(sprite)",
        "",
        "    def on_key(key):",
        "        import pygame",
        "        if key == pygame.K_q:",
        "            pyunicodegame.quit()",
        "",
        "    pyunicodegame.run(on_key=on_key)",
        "",
        "",
        'if __name__ == "__main__":',
        '    main()',
        '',
    ])

    return '\n'.join(lines)


def generate_scene_code(filename: str) -> str:
    """Generate executable Python code for the scene"""
    lines = [
        '#!/usr/bin/env python3',
        '"""',
        f'Scene: {filename} - Generated by scene_editor',
        '"""',
        '',
        'import pygame',
        'import pyunicodegame',
    ]

    # Collect unique library paths used by sprite instances
    used_libraries = set()
    for instance in state.sprite_instances.values():
        lib_path = instance.library_key.split(':')[0]
        used_libraries.add(lib_path)

    # Generate imports for sprite libraries
    lib_imports = {}  # lib_path -> module_name
    for lib_path in sorted(used_libraries):
        # Create a valid Python identifier from the path
        module_name = os.path.splitext(os.path.basename(lib_path))[0]
        module_name = module_name.replace('-', '_').replace(' ', '_')
        lib_imports[lib_path] = module_name

    if lib_imports:
        lines.append('')
        lines.append('# Sprite library imports')
        for lib_path, module_name in lib_imports.items():
            # Import path relative to scene file
            import_path = lib_path.replace('/', '.').replace('.py', '')
            if '.' in import_path:
                lines.append(f'from {import_path} import SPRITE_DEFS as {module_name}_SPRITES')
            else:
                lines.append(f'from {import_path} import SPRITE_DEFS as {module_name}_SPRITES')

    lines.extend([
        '',
        '',
        'def render_scene(window):',
        '    """Render static character placements to the scene"""',
    ])

    # Group cells by row for cleaner output
    rows = {}
    for (x, y), cell in sorted(state.cells.items()):
        if y not in rows:
            rows[y] = []
        rows[y].append((x, cell))

    if rows:
        for y in sorted(rows.keys()):
            lines.append(f'    # Row {y}')
            for x, cell in rows[y]:
                char_repr = repr(cell.char)
                fg_repr = str(cell.fg)
                if cell.bg:
                    lines.append(f'    window.put({x}, {y}, {char_repr}, {fg_repr})  # bg: {cell.bg}')
                else:
                    lines.append(f'    window.put({x}, {y}, {char_repr}, {fg_repr})')
    else:
        lines.append('    pass  # No static characters')

    # Generate sprite creation function
    lines.extend([
        '',
        '',
        'def create_scene_sprites(window):',
        '    """Create and position sprite instances in the scene"""',
        '    sprites = {}',
    ])

    if state.sprite_instances:
        lines.append('')
        for instance_id, instance in sorted(state.sprite_instances.items()):
            lib_path = instance.library_key.split(':')[0]
            sprite_name = instance.library_key.split(':')[1]
            module_name = lib_imports.get(lib_path, 'unknown')

            lines.append(f"    # {instance_id}")
            lines.append(f"    sprites['{instance_id}'] = pyunicodegame.Sprite(")
            lines.append(f"        {module_name}_SPRITES['{sprite_name}'],")
            lines.append(f"        {instance.x}, {instance.y}")
            lines.append(f"    )")
            lines.append(f"    window.add_sprite(sprites['{instance_id}'])")
            if instance.initial_animation:
                lines.append(f"    sprites['{instance_id}'].play_animation('{instance.initial_animation}')")
            lines.append('')
    else:
        lines.append('    pass  # No sprite instances')
        lines.append('')

    lines.extend([
        '    return sprites',
        '',
        '',
        'def main():',
        f'    root = pyunicodegame.init(',
        f'        "Scene",',
        f'        width={state.canvas_width},',
        f'        height={state.canvas_height},',
        f'        bg=(10, 10, 20, 255)',
        f'    )',
        '',
        '    sprites = create_scene_sprites(root)',
        '',
        '    def render():',
        '        render_scene(root)',
        '',
        '    def update(dt):',
        '        root.update_sprites(dt)',
        '',
        '    def on_key(key):',
        '        if key == pygame.K_q:',
        '            pyunicodegame.quit()',
        '',
        '    pyunicodegame.run(render=render, update=update, on_key=on_key)',
        '',
        '',
        '# Scene metadata for editor reload',
        '_SCENE_META = {',
        f"    'width': {state.canvas_width},",
        f"    'height': {state.canvas_height},",
        "    'char_placements': {",
    ])

    # Add cell data for reloading
    for (x, y), cell in sorted(state.cells.items()):
        char_repr = repr(cell.char)
        fg_repr = str(list(cell.fg))
        bg_repr = str(list(cell.bg)) if cell.bg else 'None'
        lines.append(f"        ({x}, {y}): {{'char': {char_repr}, 'fg': {fg_repr}, 'bg': {bg_repr}}},")

    lines.extend([
        '    },',
        "    'sprite_instances': {",
    ])

    # Add sprite instance data for reloading
    for instance_id, instance in sorted(state.sprite_instances.items()):
        lines.append(f"        '{instance_id}': {{")
        lines.append(f"            'library_key': '{instance.library_key}',")
        lines.append(f"            'x': {instance.x},")
        lines.append(f"            'y': {instance.y},")
        if instance.initial_animation:
            lines.append(f"            'initial_animation': '{instance.initial_animation}',")
        else:
            lines.append(f"            'initial_animation': None,")
        lines.append(f"        }},")

    lines.extend([
        '    },',
        "    'sprite_library': [",
    ])

    # Add library paths for reloading
    for lib_path in sorted(state.sprite_library.keys()):
        lines.append(f"        '{lib_path}',")

    lines.extend([
        '    ],',
        '}',
        '',
        '',
        'if __name__ == "__main__":',
        '    main()',
        '',
    ])

    return '\n'.join(lines)


def load_file(path: str, setup_sprite_window_func, load_sprite_library_func, refresh_all_scene_sprites_func):
    """Load sprite or scene from Python file

    Args:
        path: File path to load
        setup_sprite_window_func: Function to recreate sprite window
        load_sprite_library_func: Function to load sprite library
        refresh_all_scene_sprites_func: Function to refresh scene sprites
    """
    if not path.endswith('.py'):
        path += '.py'

    # Try generated_files/ if file not found directly
    if not os.path.exists(path) and not os.path.isabs(path):
        gen_path = os.path.join(GENERATED_DIR, path)
        if os.path.exists(gen_path):
            path = gen_path

    try:
        with open(path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Temporarily add file's directory to sys.path for imports
        file_dir = os.path.dirname(os.path.abspath(path))
        sys.path.insert(0, file_dir)

        try:
            # Execute file to get metadata
            # Include pyunicodegame and pygame in namespace since files import them
            namespace = {'pyunicodegame': pyunicodegame, 'pygame': pygame}
            exec(content, namespace)
        finally:
            # Remove from path
            if file_dir in sys.path:
                sys.path.remove(file_dir)

        # Check if it's a sprite file (has SPRITE_DEFS)
        if 'SPRITE_DEFS' in namespace:
            load_sprite_from_defs(path, namespace['SPRITE_DEFS'], setup_sprite_window_func)
            return

        # Otherwise try scene format (_SCENE_META)
        if '_SCENE_META' not in namespace:
            state.set_status("No SPRITE_DEFS or _SCENE_META found")
            return

        meta = namespace['_SCENE_META']

        # Load canvas dimensions
        state.editor_mode = "scene"
        state.canvas_width = meta.get('width', DEFAULT_CANVAS_WIDTH)
        state.canvas_height = meta.get('height', DEFAULT_CANVAS_HEIGHT)

        # Load cells (support both old 'cells' and new 'char_placements' key)
        state.cells.clear()
        cell_data_dict = meta.get('char_placements', meta.get('cells', {}))
        for (x, y), cell_data in cell_data_dict.items():
            cell = Cell(
                char=cell_data['char'],
                fg=tuple(cell_data['fg']),
                bg=tuple(cell_data['bg']) if cell_data.get('bg') else None
            )
            state.cells[(x, y)] = cell

        # Load sprite library files (relative to scene file)
        state.sprite_library.clear()
        scene_dir = os.path.dirname(os.path.abspath(path))
        for lib_path in meta.get('sprite_library', []):
            full_path = os.path.join(scene_dir, lib_path) if not os.path.isabs(lib_path) else lib_path
            if os.path.exists(full_path):
                load_sprite_library_func(lib_path, scene_dir)
            else:
                state.set_status(f"Warning: library not found: {lib_path}")

        # Load sprite instances
        state.sprite_instances.clear()
        state.instance_counter = 0
        for instance_id, inst_data in meta.get('sprite_instances', {}).items():
            instance = SpriteInstance(
                library_key=inst_data['library_key'],
                instance_id=instance_id,
                x=inst_data['x'],
                y=inst_data['y'],
                initial_animation=inst_data.get('initial_animation')
            )
            state.sprite_instances[instance_id] = instance
            # Track highest instance counter
            try:
                num = int(instance_id.split('_')[-1])
                if num > state.instance_counter:
                    state.instance_counter = num
            except ValueError:
                pass

        state.file_path = path
        state.modified = False
        state.cursor_x = 0
        state.cursor_y = 0
        state.scene_tool = "char"
        state.selected_library_sprite = None

        # Recreate scene window with loaded dimensions
        setup_sprite_window_func()

        # Create preview sprites for all placed instances
        refresh_all_scene_sprites_func()

        sprite_count = len(state.sprite_instances)
        lib_count = len(state.sprite_library)
        state.set_status(f"Loaded scene: {len(state.cells)} chars, {sprite_count} sprites, {lib_count} libs")

    except FileNotFoundError:
        state.set_status(f"File not found: {path}")
    except Exception as e:
        state.set_status(f"Error loading: {e}")


def load_sprite_from_defs(path: str, sprite_defs: dict, setup_sprite_window_func):
    """Load a sprite from SPRITE_DEFS format"""
    if not sprite_defs:
        state.set_status("SPRITE_DEFS is empty")
        return

    # Load the first sprite (or could be enhanced to let user choose)
    sprite_name = list(sprite_defs.keys())[0]
    defn = sprite_defs[sprite_name]

    state.editor_mode = "sprite"
    state.sprite_name = sprite_name
    state.canvas_width = defn.get('width', 8)
    state.canvas_height = defn.get('height', 6)
    state.current_fg = tuple(defn.get('default_fg', DEFAULT_FG))

    # Recreate sprite window with loaded dimensions
    setup_sprite_window_func()

    # Load frames
    state.frames = []
    for frame_data in defn.get('frames', [{}]):
        frame = SpriteFrame.from_dict(frame_data)
        state.frames.append(frame)

    if not state.frames:
        state.frames = [SpriteFrame()]

    # Load animations
    state.animations.clear()
    if 'animations' in defn:
        for anim_name, anim_data in defn['animations'].items():
            anim_frames = [
                AnimationFrame(frame_index=f[0], offset_x=f[1], offset_y=f[2])
                for f in anim_data.get('frames', [])
            ]
            state.animations[anim_name] = AnimationDef(
                name=anim_name,
                frames=anim_frames,
                frame_duration=anim_data.get('frame_duration', 0.2),
                loop=anim_data.get('loop', True),
            )

    # Load first frame into cells
    state.current_frame = 0
    state.cells = dict(state.frames[0].cells)

    state.file_path = path
    state.modified = False
    state.cursor_x = 0
    state.cursor_y = 0

    frame_info = f", {len(state.frames)} frames" if len(state.frames) > 1 else ""
    anim_info = f", {len(state.animations)} anims" if state.animations else ""
    state.set_status(f"Loaded sprite: {sprite_name} {state.canvas_width}x{state.canvas_height}{frame_info}{anim_info}")
